# Ocaml modules

IMHO, one of the most difficult things in OCaml is its module system. Modules are the way to organize codebase, and there are modules and module types in OCaml.

**Module type** is akin to an interface in Java, and contains module signature. Signature in OCaml is a set of types and
values that a module allows other modules to use. Since functions are values, modules contain functions.
Here is an example of a (module) type:

    module type SET
      sig
        type set
        type element
        val member: element -> set -> bool
      end
    ;;

This type also happens to be generic, we haven't specified what type of elements this module type' implementation will contain.

We can use this generic type to generate more specific types using 'sharing constraint'.

    module type STRING_SET =
      SET with type element = string ;;

And here is another one:

    module type INT_SET =
      SET with type element = int ;;

In a way, this technique is generics for interfaces, if I were to provide parallels with OOP.

And for visual people like myself:

              SET
             /   \
    STRING_SET   INT_SET

None of these are actually what we would consider concrete classes, just more specific versions of a more generic SET.

**Module** is a concrete implementation of a module type.
Modules may or may not have types applied to them. There are two important rules in play here:

* If a module has a type applied to it, code using that module can only access types and values (including functions) that were defined in that type.
* if a module doesn't have a type applied explicitly, it will get a default type generated by OCaml. This generated type will make all types and values available to the outside users.

Modules are sometime called implementations, because they provide concrete implementations of a module type. They actually have code containing all the logic and do things, as opposed to the type, that only contains signature.

With modules, we have a choice: we can either write each one, or define a **functor**, something like a template that we can use to generate similar modules with varying types.

**Functor** is more interesting and practical idea, because it allows code reuse.

Here is an example:

    module MakeSet(C: COMPARABLE) : (SET with type element = C.t) =
      struct
      (* ...actual functions and types... *)
      end
    ;;

Once again, the syntax is terse. `(C: COMPARABLE)` means that this functor can accept any module implementing `COMPARABLE` type. This parameter is assigned to `C`. Because of this restriction, we are guaranteed to have access to types defined inside of the COMPARABLE, like `t`.

`(SET with type element = C.t)` means that this functor will return a module that will implement `SET`. Additionally, it provides sharing constraint on the returned module type: `type element = C.t`. The elements of the module this functor returns will be of the type that was passed as `C.t`.
